<<<<<<< HEAD
for(iter in 1:n.iter){
th  <- sample.th(th,sig)
sig <- sample.sig(th)
th  <- sample.ths(th,sig)
## update running summaries #################
if (iter>n.iter/2){
f   <- fbar(xgrid,th,sig)
lines(xgrid,f,col=iter,lty=3)
fgrid <- rbind(fgrid,f)
nj <- table(th)                 # counts
njlist <- rbind(njlist,sort(nj,decr=T)[1:8])
klist <- c(klist,length(nj))
}
}
## report summaries ###########################
fbar <- apply(fgrid,2,mean)
lines(xgrid,fbar,lwd=3,col=2)
njbar <- apply(njlist,2,mean,na.rm=T)
cat("Average cluster sizes:\n",format(njbar),"\n")
pk <- table(klist)/length(klist)
cat("Posterior probs p(k): (row1 = k, row2 = p(k) \n ")
print(pk/sum(pk))
return(list(fgrid=fgrid,klist=klist,njlist=njlist))
}
mcmc <- gibbs()
length(X)
gibbs.H <- function(n.iter=5000){
xgrid <- seq(from= -10, to=10,length=100)
cgrid<- seq(from= 0, to=10,length=100)
fgrid <- NULL
ecfgrid <- NULL
plot(density(X),xlab="X",ylab="Y",bty="l",type="l",xlim=c(-10, 10),ylim=c(0,1), main="")
for(iter in floor(nrow(theta.matrix)/2):nrow(theta.matrix)){
## record draw F ~ p(F | th,sig,y) (approx)
f   <- fbar.H_base(xgrid,theta.matrix[iter,])
#  ecf<- ecfbar.H_base(cgrid,theta.matrix[iter,])
lines(xgrid,f,col=iter,lty=3)
fgrid <- rbind(fgrid,f)
#  ecfgrid <- rbind(ecfgrid,ecf)
}
## add overall average (= posterior mean) to the plot
fbar <- apply(fgrid,2,mean)
lines(xgrid,fbar,lwd=3,col=2)
plot(ecdf(X),xlab="X",ylab="Y",bty="l", main="")
for(iter in floor(nrow(theta.matrix)/2):nrow(theta.matrix)){
## record draw F ~ p(F | th,sig,y) (approx)
ecf<- ecfbar.H_base(cgrid,theta.matrix[iter,])
lines(cgrid,ecf,col=iter,lty=3)
ecfgrid <- rbind(ecfgrid,ecf)
}
## add overall average (= posterior mean) to the plot
fbar <- apply(fgrid,2,mean)
ecfbar<- apply(ecfgrid,2,mean)
lines(cgrid,ecfbar,lwd=3,col=2)
return(list(f_ap=fbar, ecf=ecfbar))
}
f_approx<- gibbs.H()
ks.test(f_approx$ecf, ecdf(X))
length(X)
gibbs.H <- function(n.iter=1000){
xgrid <- seq(from= -10, to=10,length=100)
cgrid<- seq(from= 0, to=10,length=100)
fgrid <- NULL
ecfgrid <- NULL
plot(density(X),xlab="X",ylab="Y",bty="l",type="l",xlim=c(-10, 10),ylim=c(0,1), main="")
for(iter in floor(nrow(theta.matrix)/2):nrow(theta.matrix)){
## record draw F ~ p(F | th,sig,y) (approx)
f   <- fbar.H_base(xgrid,theta.matrix[iter,])
#  ecf<- ecfbar.H_base(cgrid,theta.matrix[iter,])
lines(xgrid,f,col=iter,lty=3)
fgrid <- rbind(fgrid,f)
#  ecfgrid <- rbind(ecfgrid,ecf)
}
## add overall average (= posterior mean) to the plot
fbar <- apply(fgrid,2,mean)
lines(xgrid,fbar,lwd=3,col=2)
plot(ecdf(X),xlab="X",ylab="Y",bty="l", main="")
for(iter in floor(nrow(theta.matrix)/2):nrow(theta.matrix)){
## record draw F ~ p(F | th,sig,y) (approx)
ecf<- ecfbar.H_base(cgrid,theta.matrix[iter,])
lines(cgrid,ecf,col=iter,lty=3)
ecfgrid <- rbind(ecfgrid,ecf)
}
## add overall average (= posterior mean) to the plot
fbar <- apply(fgrid,2,mean)
ecfbar<- apply(ecfgrid,2,mean)
lines(cgrid,ecfbar,lwd=3,col=2)
return(list(f_ap=fbar, ecf=ecfbar))
}
f_approx<- gibbs.H()
gibbs.H <- function(n.iter=1000){
xgrid <- seq(from= 0, to=10,length=100)
cgrid<- seq(from= 0, to=10,length=100)
fgrid <- NULL
ecfgrid <- NULL
plot(density(X),xlab="X",ylab="Y",bty="l",type="l",xlim=c(0, 10),ylim=c(0,1), main="")
for(iter in floor(nrow(theta.matrix)/2):nrow(theta.matrix)){
## record draw F ~ p(F | th,sig,y) (approx)
f   <- fbar.H_base(xgrid,theta.matrix[iter,])
#  ecf<- ecfbar.H_base(cgrid,theta.matrix[iter,])
lines(xgrid,f,col=iter,lty=3)
fgrid <- rbind(fgrid,f)
#  ecfgrid <- rbind(ecfgrid,ecf)
}
## add overall average (= posterior mean) to the plot
fbar <- apply(fgrid,2,mean)
lines(xgrid,fbar,lwd=3,col=2)
plot(ecdf(X),xlab="X",ylab="Y",bty="l", main="")
for(iter in floor(nrow(theta.matrix)/2):nrow(theta.matrix)){
## record draw F ~ p(F | th,sig,y) (approx)
ecf<- ecfbar.H_base(cgrid,theta.matrix[iter,])
lines(cgrid,ecf,col=iter,lty=3)
ecfgrid <- rbind(ecfgrid,ecf)
}
## add overall average (= posterior mean) to the plot
fbar <- apply(fgrid,2,mean)
ecfbar<- apply(ecfgrid,2,mean)
lines(cgrid,ecfbar,lwd=3,col=2)
return(list(f_ap=fbar, ecf=ecfbar))
}
f_approx<- gibbs.H()
ks.test(f_approx$ecf, ecdf(X))
gibbs <- function(n.iter=5000){
th <- init.DPk()              ## initialize th[1..n]
sig <- sqrt( mean((y-th)^2))  ## and sig
## set up data structures to record imputed posterior draws..1
xgrid <- seq(from=-2,to=10,length=50)
fgrid <- NULL     ## we will record imputed draws of f
njlist <- NULL    ## record sizes of 8 largest clusters
klist <- NULL
## start with a plot of a kernel density estimate of the data
plot(density(y),xlab="X",ylab="Y",bty="l",type="l",
xlim=c(-2,10),ylim=c(0,0.7), main="")
## now the Gibbs sampler
for(iter in 1:n.iter){
th  <- sample.th(th,sig)
sig <- sample.sig(th)
th  <- sample.ths(th,sig)
## update running summaries #################
if (iter>n.iter/2){
f   <- fbar(xgrid,th,sig)
lines(xgrid,f,col=iter,lty=3)
fgrid <- rbind(fgrid,f)
nj <- table(th)                 # counts
njlist <- rbind(njlist,sort(nj,decr=T)[1:8])
klist <- c(klist,length(nj))
}
}
## report summaries ###########################
fbar <- apply(fgrid,2,mean)
lines(xgrid,fbar,lwd=3,col=2)
njbar <- apply(njlist,2,mean,na.rm=T)
cat("Average cluster sizes:\n",format(njbar),"\n")
pk <- table(klist)/length(klist)
cat("Posterior probs p(k): (row1 = k, row2 = p(k) \n ")
print(pk/sum(pk))
return(list(fgrid=fgrid,klist=klist,njlist=njlist))
}
mcmc <- gibbs()
#dir <- "/home/pmueller/pap/12/ba/eig121/"
#setwd(dir)
setwd("~/Documents/GitHub/gjamed")
############################################
## Example 4 - Gene expression
## DPM
## implementing MCMC with finite DP
## Sec 2.4.6.
## MODEL:
## y_i | th_i ~ N(th_i, sig^2)
## th_i       ~ G and
## G          ~ DP(M, G0) with G0=N(0,4)
## hyperprior:
## 1/sig ~ Ga(a,b), a=1, b=1
##
## We use the usual notation for unique values ths[1..k] and
##        s_i = j if th_i = ths_j
## Denote with F(y) = \int N(y; th,sig) dG(th)
##        and  f(y) = pdf
##
## Posterior MCMC for DPM models
## (b) using the blocked Gibbs sampler
##         H
##     G = sum w_h delta(m_h)
##         h=1
##     recall: w_h = v_h (1-\sum_{g<h} w_g)
##             r_i = h iff th_i = m_h
##
##     We iterate over the following transition probabilities, sampling
##     from complete conditional posterior distributions:
##     1. r_i   ~ p(r_i   | ... ), i=1..n
##     2. m_h   ~ p(m_h   | ... ), h=1..H
##     3. v_h   ~ p(v_h   | ... ), h=1..H
##     4. sig   ~ p(sig   | ... )
## EIG 121 data
read.dta <- function()
{
X <- read.table("EIG.txt",header=1)
y <- X$recorded
y <- log( y[!is.na(y)] )  # log EIG121 expression
n <- length(y)
return(dta=list(y=y, n=n))
}
## hyperparameters
a <- 1;   b <- 1     # 1/sig ~ Ga(a,b)
m0 <- -3;  B0 <- 4    # G0 = N(m0,B0)
M <- 1
H <- 10
init.DPk <- function()
{ ## inital EDA estimate of G = sum_{h=1..10} w_h delta(m_h)
## returns:
##   list(mh,wh)
## use (mh,wh) to initialize the blocked Gibbs
## cluster data, and cut at height H=10, to get 10 clusters
hc <- hclust(dist(y)^2, "cen")
r  <- cutree(hc, k = 10)
## record cluster specific means, order them
mh1 <- sapply(split(y,r),mean)    # cluster specific means == m_h
wh1 <- table(r)/n
idx <- order(wh1,decreasing=T)    # re-arrange in deceasing order
mh <- mh1[idx]
wh <- wh1[idx]
return(list(mh=mh,wh=wh,r=r))
}
# ##################################################################
# 2. Blocked GS
# ##################################################################
gibbs.H <- function(n.iter=500)
{
G <- init.DPk()
sig <- 0.11
## data structures to save imputed F ~ p(F | ...)
xgrid <- seq(from= -10, to=2,length=50)
fgrid <- NULL
plot(density(y),xlab="X",ylab="Y",bty="l",type="l",
xlim=c(-10, 2),ylim=c(0,0.4), main="")
## Gibbs
for(iter in 1:n.iter){
G$r <-  sample.r(G$wh,G$mh,sig)   # 1. r_i ~ p(r_i | ...), i=1..n
G$mh <- sample.mh(G$wh,G$r,sig)   # 2. m_h ~ p(m_h | ...), h=1..H
G$vh <- sample.vh(G$r)            # 3. v_h ~ p(v_h | ...), h=1..H
th <- G$mh[G$r]                   # record implied th[i] = mh[r[i]]
sig <- sample.sig(th)       # 4. sig ~ p(sig | ...)
## record draw F ~ p(F | th,sig,y) (approx)
f   <- fbar.H(xgrid,G$wh,G$mh,sig)
lines(xgrid,f,col=iter,lty=3)
fgrid <- rbind(fgrid,f)
}
## add overall average (= posterior mean) to the plot
fbar <- apply(fgrid,2,mean)
lines(xgrid,fbar,lwd=3,col=2)
return(fgrid)
}
sample.r <- function(wh,mh,sig)
{ ## samle allocation indicators
r <- rep(0,n)
for(i in 1:n){
ph <-   dnorm(y[i],m=mh,sd=sig)*wh # likelihood   * prior
## p(yi | ri=h) * w_h
r[i] <- sample(1:H,1,prob=ph)
}
return(r)
}
sample.mh <- function(wh,r,sig)
{ ## sample mh ~ p(mh | ...)
##
mh <- rep(0,H)     # initialize
for(h in 1:H){
if(any(r==h)){      # some data assigned to h-th pointmass
Sh <- which(r==h) # Sh = {i: r[i]=h
nh <- length(Sh)
ybarh <- mean(y[Sh])
varh   <- 1.0/(1/B0 + nh/sig^2)
meanh  <- varh*(1/B0*m0 + nh/sig^2*ybarh)
} else {            # no data assinged to h-th pointmass
varh  <- B0       # sample from base measure
meanh <- m0
}
mh[h] <- rnorm(1,m=meanh,sd=sqrt(varh))
}
return(mh)
}
sample.vh <- function(r)
{## sample vh ~ p(vh | ...)
## returns: wh
vh <- rep(0,H)  # initialize
wh <- rep(0,H)
V <-  1         # record prod_{g<h} (1-vh_h)
for(h in 1:(H-1)){
Ah <- which(r==h)
Bh <- which(r>h)
vh[h] <-  rbeta(1, 1+length(Ah), M+length(Bh))
wh[h] <- vh[h]*V
V <- V*(1-vh[h])
}
vh[H] <- 1.0
wh[H] <- V
return(wh)
}
fbar.H <- function(xgrid,wh,mh,sig)
{ ## return a draw F ~ p(F | ...) (approx)
fx <- rep(0,length(xgrid))
for(h in 1:H)
fx <- fx + wh[h]*dnorm(xgrid,m=mh[h],sd=sig)
return(fx)
}
sample.sig <- function(th)
{ ## sample
##   sig ~ p(sig | ...)
## returns: sig
s2 <- sum( (y-th)^2 )    # sum of squared residuals
a1 <- a+0.5*n
b1 <- b+0.5*s2
s2.inv <- rgamma(1,shape=a1,rate=b1)
return(1/sqrt(s2.inv))
}
plt.all <- function(fgrid,sim=T,dens=T)
{
xgrid <- seq(from= -10, to=2,length=50)
M <- nrow(fgrid)
idx0 <- 21:M
fgrid0 <- fgrid[idx0,]            # drop initial transient
idx1 <- which(idx0 %% 5 == 0 )    # thin out for plotting
fgrid1 <- fgrid[idx1,]
fbar <- apply(fgrid0,2,mean)
plot(xgrid,fbar,xlab="log(EIG121)", ylab="G",
type="l",lwd=3,bty="l",ylim=c(0,0.9))
if(sim){
matlines(xgrid,t(fgrid1),col=1)
## matlines(xgrid,t(fgrid0),col=2)
lines(xgrid,fbar,type="l",lwd=4,col="grey")
}
if (dens){
lines(density(y),col="yellow",lty=2,lwd=4)
}
}
plt.dta <- function()
{
hist(y,main="",xlab="log(EIG121)",ylab="FREQ",prob=T)
}
ex <- function()
{
dta <- read.dta()
attach(dta)
## run MCMC
fgrid <- gibbs.H()
plt.dta()
plt.all(fgrid)
}
ex()
n
## hyperparameters
a <- 1;   b <- 1     # 1/sig ~ Ga(a,b)
m0 <- -3;  B0 <- 4    # G0 = N(m0,B0)
M <- 1
H <- 10
init.DPk <- function()
{ ## inital EDA estimate of G = sum_{h=1..10} w_h delta(m_h)
## returns:
##   list(mh,wh)
## use (mh,wh) to initialize the blocked Gibbs
## cluster data, and cut at height H=10, to get 10 clusters
hc <- hclust(dist(y)^2, "cen")
r  <- cutree(hc, k = 10)
## record cluster specific means, order them
mh1 <- sapply(split(y,r),mean)    # cluster specific means == m_h
wh1 <- table(r)/n
idx <- order(wh1,decreasing=T)    # re-arrange in deceasing order
mh <- mh1[idx]
wh <- wh1[idx]
return(list(mh=mh,wh=wh,r=r))
}
fbar.H_base <- function(xgrid,wh)
{ ## return a draw F ~ p(F | ...) (approx)
fx <- rep(0,length(xgrid))
fb <- rep(0,length(xgrid))
for(h in 1:length(wh)){
fx <- fx + dnorm(xgrid,m=wh[h],sd=1)
fx_m<- fx/ (length(wh)+ alpha)
}
fx_m<- fx/ (length(wh)+ alpha)
fx_m<- fx_m +  alpha/(length(wh)+alpha)*dnorm(xgrid,m=0,sd=sqrt(2))
return(fx_m)
}
alpha=1
length(wh)
ecfbar.H_base <- function(xgrid,wh)
{ ## return a draw F ~ p(F | ...) (approx)
fx <- rep(0,length(xgrid))
for(h in 1:length(wh)){
fx <- fx + pnorm(xgrid,m=wh[h],sd=1)
}
fx_m<- fx/ (length(wh)+ alpha)
fx_m<- fx_m +  alpha/(length(wh)+alpha)*pnorm(xgrid,m=0,sd=sqrt(2))
return(fx_m)
}
gibbs.H <- function(n.iter=10000){
xgrid <- seq(from= 0, to=10,length=100)
cgrid<- seq(from= 0, to=10,length=100)
fgrid <- NULL
ecfgrid <- NULL
plot(density(X),xlab="X",ylab="Y",bty="l",type="l",xlim=c(0, 10),ylim=c(0,1), main="")
for(iter in floor(nrow(theta.matrix)/2):nrow(theta.matrix)){
## record draw F ~ p(F | th,sig,y) (approx)
f   <- fbar.H_base(xgrid,theta.matrix[iter,])
#  ecf<- ecfbar.H_base(cgrid,theta.matrix[iter,])
lines(xgrid,f,col=iter,lty=3)
fgrid <- rbind(fgrid,f)
#  ecfgrid <- rbind(ecfgrid,ecf)
}
## add overall average (= posterior mean) to the plot
fbar <- apply(fgrid,2,mean)
lines(xgrid,fbar,lwd=3,col=2)
plot(ecdf(X),xlab="X",ylab="Y",bty="l", main="")
for(iter in floor(nrow(theta.matrix)/2):nrow(theta.matrix)){
## record draw F ~ p(F | th,sig,y) (approx)
ecf<- ecfbar.H_base(cgrid,theta.matrix[iter,])
lines(cgrid,ecf,col=iter,lty=3)
ecfgrid <- rbind(ecfgrid,ecf)
}
## add overall average (= posterior mean) to the plot
fbar <- apply(fgrid,2,mean)
ecfbar<- apply(ecfgrid,2,mean)
lines(cgrid,ecfbar,lwd=3,col=2)
return(list(f_ap=fbar, ecf=ecfbar))
}
f_approx<- gibbs.H()
ks.test(f_approx$ecf, ecdf(X))
nrow(theta.matrix)
gibbs.H <- function(n.iter=10000){
xgrid <- seq(from= 0, to=10,length=100)
cgrid<- seq(from= 0, to=10,length=100)
fgrid <- NULL
ecfgrid <- NULL
plot(density(X),xlab="X",ylab="Y",bty="l",type="l",xlim=c(0, 10),ylim=c(0,1), main="")
for(iter in floor(nrow(theta.matrix)/4):nrow(theta.matrix)){
## record draw F ~ p(F | th,sig,y) (approx)
f   <- fbar.H_base(xgrid,theta.matrix[iter,])
#  ecf<- ecfbar.H_base(cgrid,theta.matrix[iter,])
lines(xgrid,f,col=iter,lty=3)
fgrid <- rbind(fgrid,f)
#  ecfgrid <- rbind(ecfgrid,ecf)
}
## add overall average (= posterior mean) to the plot
fbar <- apply(fgrid,2,mean)
lines(xgrid,fbar,lwd=3,col=2)
plot(ecdf(X),xlab="X",ylab="Y",bty="l", main="")
for(iter in floor(nrow(theta.matrix)/2):nrow(theta.matrix)){
## record draw F ~ p(F | th,sig,y) (approx)
ecf<- ecfbar.H_base(cgrid,theta.matrix[iter,])
lines(cgrid,ecf,col=iter,lty=3)
ecfgrid <- rbind(ecfgrid,ecf)
}
## add overall average (= posterior mean) to the plot
fbar <- apply(fgrid,2,mean)
ecfbar<- apply(ecfgrid,2,mean)
lines(cgrid,ecfbar,lwd=3,col=2)
return(list(f_ap=fbar, ecf=ecfbar))
}
f_approx<- gibbs.H()
fbar.H_base <- function(xgrid,wh)
{ ## return a draw F ~ p(F | ...) (approx)
fx <- rep(0,length(xgrid))
fb <- rep(0,length(xgrid))
for(h in 1:length(wh)){
fx <- fx + dnorm(xgrid,m=wh[h],sd=1)
}
fx_m<- fx/ (length(wh)+ alpha)
fx_m<- fx_m +  alpha/(length(wh)+alpha)*dnorm(xgrid,m=0,sd=sqrt(2))
return(fx_m)
}
ecfbar.H_base <- function(xgrid,wh)
{ ## return a draw F ~ p(F | ...) (approx)
fx <- rep(0,length(xgrid))
for(h in 1:length(wh)){
fx <- fx + pnorm(xgrid,m=wh[h],sd=1)
}
fx_m<- fx/ (length(wh)+ alpha)
fx_m<- fx_m +  alpha/(length(wh)+alpha)*pnorm(xgrid,m=0,sd=sqrt(2))
return(fx_m)
}
gibbs.H <- function(n.iter=10000){
xgrid <- seq(from= 0, to=10,length=100)
cgrid<- seq(from= 0, to=10,length=100)
fgrid <- NULL
ecfgrid <- NULL
plot(density(X),xlab="X",ylab="Y",bty="l",type="l",xlim=c(0, 10),ylim=c(0,1), main="")
for(iter in floor(nrow(theta.matrix)/4):nrow(theta.matrix)){
## record draw F ~ p(F | th,sig,y) (approx)
f   <- fbar.H_base(xgrid,theta.matrix[iter,])
#  ecf<- ecfbar.H_base(cgrid,theta.matrix[iter,])
lines(xgrid,f,col=iter,lty=3)
fgrid <- rbind(fgrid,f)
#  ecfgrid <- rbind(ecfgrid,ecf)
}
## add overall average (= posterior mean) to the plot
fbar <- apply(fgrid,2,mean)
lines(xgrid,fbar,lwd=3,col=2)
plot(ecdf(X),xlab="X",ylab="Y",bty="l", main="")
for(iter in floor(nrow(theta.matrix)/2):nrow(theta.matrix)){
## record draw F ~ p(F | th,sig,y) (approx)
ecf<- ecfbar.H_base(cgrid,theta.matrix[iter,])
lines(cgrid,ecf,col=iter,lty=3)
ecfgrid <- rbind(ecfgrid,ecf)
}
## add overall average (= posterior mean) to the plot
fbar <- apply(fgrid,2,mean)
ecfbar<- apply(ecfgrid,2,mean)
lines(cgrid,ecfbar,lwd=3,col=2)
return(list(f_ap=fbar, ecf=ecfbar))
}
f_approx<- gibbs.H()
ks.test(f_approx$ecf, ecdf(X))
=======
library(repmis)
library(gjam)
library(MASS)
library(truncnorm)
library(coda)
library(RcppArmadillo)
library(arm)
library(Rcpp)
library(ggplot2)
Rcpp::sourceCpp('src/cppFns.cpp')
source("R/gjamHfunctions_mod.R")
source("R/simple_gjam_1.R")
source("R/simple_gjam_2.R")
source("R/simple_gjam_3.R")
source("R/simple_gjam_4.R")
d <- "https://github.com/jimclarkatduke/gjam/blob/master/forestTraits.RData?raw=True"
source_data(d)
xdata <- forestTraits$xdata[,c(1,2,8)]
formula <- as.formula( ~ temp*deficit + I(temp^2) + I(deficit^2) )
y  <- gjamReZero(forestTraits$treesDeZero)  # extract y
treeYdata  <- gjamTrimY(y,10)$y             # at least 10 plots
d
forestTraits
forestTraits$specByTrait
dim(treeYdata)
S<-ncol(treeYdata)
N_eps<-floor(.compute_tau_mean(0.3,2,0.1) + 2*.compute_tau_var(0.3,2,0.1))
rl3   <- list(r = 8, N = N_eps, sigma_py=0.3, alpha=2)
N_eps
N_eps<-floor(.compute_tau_mean(0.3,10,0.1) + 2*.compute_tau_var(0.3,10,0.1))
rl3   <- list(r = 8, N = N_eps, sigma_py=0.3, alpha=2)
N_eps
N_eps<-floor(.compute_tau_mean(0.5,10,0.1) + 2*.compute_tau_var(0.5,10,0.1))
N_eps
rl4   <- list(r = 8, N = N_eps,rate=0.1,shape=0.1,V1=1,ro.disc=0.5) #here to modify N
ml4   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl4) #change ml
ml3   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl3) #change ml
ml2   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl2) #change ml
ml1   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl1) #change ml
ml   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl) #change ml
rm(list=ls())
setwd("~/GitHub/gjamed")
library(repmis)
library(gjam)
library(MASS)
library(truncnorm)
library(coda)
library(RcppArmadillo)
library(arm)
library(Rcpp)
library(ggplot2)
Rcpp::sourceCpp('src/cppFns.cpp')
source("R/gjamHfunctions_mod.R")
source("R/simple_gjam_1.R")
source("R/simple_gjam_2.R")
source("R/simple_gjam_3.R")
source("R/simple_gjam_4.R")
d <- "https://github.com/jimclarkatduke/gjam/blob/master/forestTraits.RData?raw=True"
source_data(d)
xdata <- forestTraits$xdata[,c(1,2,8)]
y  <- gjamReZero(forestTraits$treesDeZero)  # extract y
treeYdata  <- gjamTrimY(y,10)$y             # at least 10 plots
form <- as.formula( ~ temp*deficit + I(temp^2) + I(deficit^2) )
S<-ncol(treeYdata) #95
rl <- list(r = 8, N = S)
rl1 <- list(r = 8, N = S, rate=0.1,shape=0.1)
rl2  <- list(r = 8, N = 20,rate=0.1,shape=0.1,V=1) #here to modify N
N_eps<-floor(.compute_tau_mean(0.3,10,0.1) + 2*.compute_tau_var(0.3,10,0.1)) #alpha=10,sigma=0.3
rl3   <- list(r = 8, N = N_eps, sigma_py=0.3, alpha=2)
N_eps<-floor(.compute_tau_mean(0.5,10,0.1) + 2*.compute_tau_var(0.5,10,0.1))
rl4   <- list(r = 8, N = N_eps,rate=0.1,shape=0.1,V1=1,ro.disc=0.5) #here to modify N
ml4   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl4) #change ml
ml3   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl3) #change ml
ml2   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl2) #change ml
ml1   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl1) #change ml
ml   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl) #change ml
fit<-gjam(form, xdata = xdata, ydata = treeYdata, modelList = ml)
fit1<-.gjam_1(form, xdata = xdata, ydata = treeYdata, modelList = ml1)
fit2<-.gjam_2(form, xdata = xdata, ydata = treeYdata, modelList = ml2)
rl2  <- list(r = 8, N = S,rate=0.1,shape=0.1,V=1) #here to modify N
ml2   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl2) #change ml
fit2<-.gjam_2(form, xdata = xdata, ydata = treeYdata, modelList = ml2)
fit3 <- .gjam_3(form,xdata,treeYdata,ml3)
fit4<-.gjam_4(form, xdata = xdata, ydata = treeYdata, modelList = ml4)
fit$fit$rmspeAll
fit1$fit$rmspeAll
fit2$fit$rmspeAll
fit3$fit$rmspeAll
fit4$fit$rmspeAll
alpha<-mcmc(fit4$chains$alpha.PY_g)
plot(alpha)
acfplot(alpha)
cumuplot(alpha)
discount<-mcmc(fit4$chains$discount.PY_g)
plot(discount)
acfplot(discount)
cumuplot(discount)
#check the convergence
gjam_mc<- mcmc(fit$chains$sgibbs) #thinned sigma
s2s1<- mcmc(fit$chains$sgibbs[,2]) #s2s1 chain
#acf
#acfplot(gjam_mc)  ##autocor plot
ggs_autocorrelation(ggs(gjam_mc)) ###autocr
trace0<-apply(fit$chains$kgibbs,1,function(x) length(unique(x)))
trace1<-apply(fit1$chains$kgibbs,1,function(x) length(unique(x)))
trace2<-apply(fit2$chains$kgibbs,1,function(x) length(unique(x)))
trace3<-apply(fit3$chains$kgibbs,1,function(x) length(unique(x)))
trace4<-apply(fit4$chains$kgibbs,1,function(x) length(unique(x)))
table<-data.frame()
table<-data.frame("trace"=c(trace0,trace1,trace2,trace3,trace4),
"type"=c(rep("0",length(trace0)),rep("1",length(trace1)),rep("2",length(trace2)),rep("3",length(trace3)),rep("4",length(trace4))))
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
cols = gg_color_hue(4)
p1<-ggplot(table[which(table$type=="0"),], aes(x=table$x[which(table$type=="0")],y=table$trace[which(table$type=="0")]))+geom_point()+geom_hline(yintercept = Ktr,col="red")
p1
p1<-ggplot(table[which(table$type=="0"),], aes(x=table$x[which(table$type=="0")],y=table$trace[which(table$type=="0")]))+geom_point()
p1
alpha<-mcmc(fit1$chains$alpha.PY_g)
alpha<-mcmc(fit1$chains$alpha.DP_g)
plot(alpha)
discount<-mcmc(fit4$chains$discount.PY_g)
plot(discount)
acfplot(discount)
alpha<-mcmc(fit2$chains$alpha.PY_g)
alpha<-mcmc(fit2$chains$alpha.DP_g)
plot(alpha)
acfplot(alpha)
cumuplot(alpha)
#check that alpha and sigma respected the truncation bounds
alpha<-mcmc(fit4$chains$alpha.PY_g)
plot(alpha)
discount<-mcmc(fit4$chains$discount.PY_g)
plot(discount)
#check the convergence
gjam_mc<- mcmc(fit$chains$sgibbs) #thinned sigma
s2s1<- mcmc(fit$chains$sgibbs[,2]) #s2s1 chain
#acf
#acfplot(gjam_mc)  ##autocor plot
ggs_autocorrelation(ggs(gjam_mc)) ###autocr
?ggs_autocorrelation
'?ggs_autocorrelation
??ggs_autocorrelation
''
'
??ggs_autocorrelation
library(ggmcmc)
ggs_autocorrelation(ggs(gjam_mc))
#nESS crazy low
xyplot(s2s1)
??xyplot.mcmc
library(coda)
#nESS crazy low
xyplot(s2s1)
?xyplot
hist(effectiveSize(gjam_mc), main="ess(sigma)",lwd=2,col=gray(.6),breaks=100)
effectiveSize(gjam_mc)
#cumuplot
cumuplot(s2s1)
#cumuplot
cumuplot(s2s1)
x11()
cumuplot(gjam_mc)
#check the traceplots of K
trace0<-apply(fit$chains$kgibbs,1,function(x) length(unique(x)))
trace1<-apply(fit1$chains$kgibbs,1,function(x) length(unique(x)))
trace2<-apply(fit2$chains$kgibbs,1,function(x) length(unique(x)))
trace3<-apply(fit3$chains$kgibbs,1,function(x) length(unique(x)))
trace4<-apply(fit4$chains$kgibbs,1,function(x) length(unique(x)))
table<-data.frame()
table<-data.frame("trace"=c(trace0,trace1,trace2,trace3,trace4),
"type"=c(rep("0",length(trace0)),rep("1",length(trace1)),rep("2",length(trace2)),rep("3",length(trace3)),rep("4",length(trace4))))
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
cols = gg_color_hue(5)
p1<-ggplot(table[which(table$type=="0"),], aes(x=table$x[which(table$type=="0")],y=table$trace[which(table$type=="0")]))+geom_point()
p1
dim(table[which(table$type=="0"),])
dim(table$trace[which(table$type=="0")])
head(table)
table$trace
which(table$type=="0")
table$trace[which(table$type=="0")]
table<-data.frame()
table<-data.frame("trace"=c(trace0,trace1,trace2,trace3,trace4),
"type"=c(rep("0",length(trace0)),rep("1",length(trace1)),rep("2",length(trace2)),rep("3",length(trace3)),rep("4",length(trace4))),
"x"=rep(1:it,5))
table<-data.frame("trace"=c(trace0,trace1,trace2,trace3,trace4),
"type"=c(rep("0",length(trace0)),rep("1",length(trace1)),rep("2",length(trace2)),rep("3",length(trace3)),rep("4",length(trace4))),
"x"=rep(1:5000,5))
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
cols = gg_color_hue(5)
p1<-ggplot(table[which(table$type=="0"),], aes(x=table$x[which(table$type=="0")],y=table$trace[which(table$type=="0")]))+geom_point()
p1
p2<-ggplot(table[which(table$type=="1"),], aes(x=table$x[which(table$type=="1")],y=table$trace[which(table$type=="1")]))+geom_point()+geom_hline(yintercept = Ktr,col="red")
p2<-ggplot(table[which(table$type=="1"),], aes(x=table$x[which(table$type=="1")],y=table$trace[which(table$type=="1")]))+geom_point()
p2
p3<-ggplot(table[which(table$type=="2"),], aes(x=table$x[which(table$type=="2")],y=table$trace[which(table$type=="2")]))+geom_point()
p3
p4<-ggplot(table[which(table$type=="3"),], aes(x=table$x[which(table$type=="3")],y=table$trace[which(table$type=="3")]))+geom_point()
p4
p<-ggplot(table, aes(x=x,y=trace,col=as.factor(type)))+geom_point()+
scale_color_manual(name = c(""), values = cols, labels=c("Original model","DP with prior on alpha","PY with fixed alpha, sigma","PY with prior on alpha, sigma"))
p
p<-ggplot(table, aes(x=x,y=trace,col=as.factor(type)))+geom_point()+
scale_color_manual(name = c(""), values = cols, labels=c("Original model","DP with prior on alpha 1","DP with prior on alpha 1","PY with fixed alpha, sigma","PY with prior on alpha, sigma"))
p
p<-ggplot(table, aes(x=x,y=trace,col=as.factor(type)))+geom_point()+
scale_color_manual(name = c(""), values = cols, labels=c("Original model","DP with prior on alpha 1","DP with prior on alpha 2","PY with fixed alpha, sigma","PY with prior on alpha, sigma"))+
title("Traceplots of the posterior of the number of clusters")
p
p<-ggplot(table, aes(x=x,y=trace,col=as.factor(type)))+geom_point()+
scale_color_manual(name = c(""), values = cols, labels=c("Original model","DP with prior on alpha 1","DP with prior on alpha 2","PY with fixed alpha, sigma","PY with prior on alpha, sigma"))+
labs(title="Traceplots of the posterior of the number of clusters")
p
gjam_mc<- mcmc(fit$chains$sgibbs) #thinned sigma
gjam_mc1<- mcmc(fit1$chains$sgibbs) #thinned sigma
gjam_mc2<- mcmc(fit2$chains$sgibbs) #thinned sigma
gjam_mc3<- mcmc(fit3$chains$sgibbs) #thinned sigma
gjam_mc4<- mcmc(fit4$chains$sgibbs) #thinned sigma
hist(effectiveSize(gjam_mc), main="ess(sigma)",lwd=2,col=gray(.6),breaks=100)
hist(effectiveSize(gjam_mc1), main="ess(sigma)",lwd=2,col=gray(.6),breaks=100)
hist(effectiveSize(gjam_mc2), main="ess(sigma)",lwd=2,col=gray(.6),breaks=100)
hist(effectiveSize(gjam_mc3), main="ess(sigma)",lwd=2,col=gray(.6),breaks=100)
hist(effectiveSize(gjam_mc4), main="ess(sigma)",lwd=2,col=gray(.6),breaks=100)
par(mfrow=c(2,3))
hist(effectiveSize(gjam_mc), main="ess(sigma) gjam",lwd=2,col=gray(.6),breaks=100)
hist(effectiveSize(gjam_mc1), main="ess(sigma) gjam1",lwd=2,col=gray(.6),breaks=100)
hist(effectiveSize(gjam_mc2), main="ess(sigma) gjam2",lwd=2,col=gray(.6),breaks=100)
hist(effectiveSize(gjam_mc3), main="ess(sigma) gjam3",lwd=2,col=gray(.6),breaks=100)
hist(effectiveSize(gjam_mc4), main="ess(sigma) gjam4",lwd=2,col=gray(.6),breaks=100)
#check that alpha and sigma respected the truncation bounds
alpha<-mcmc(fit4$chains$alpha.PY_g)
plot(alpha)
discount<-mcmc(fit4$chains$discount.PY_g)
plot(discount)
alpha<-mcmc(fit2$chains$alpha.PY_g)
alpha<-mcmc(fit2$chains$alpha.DP_g)
plot(alpha)
fit$fit$rmspeAll
fit1$fit$rmspeAll
fit2$fit$rmspeAll
fit3$fit$rmspeAll
fit4$fit$rmspeAll
beta_mcmc<-mcmc(fit$chains$bgibbs)
beta_mcmc1<-mcmc(fit1$chains$bgibbs)
beta_mcmc2<-mcmc(fit2$chains$bgibbs)
beta_mcmc3<-mcmc(fit3$chains$bgibbs)
beta_mcmc4<-mcmc(fit4$chains$bgibbs)
#nESS
hist(effectiveSize(beta_mcmc), main="ess(beta) gjam",lwd=2,col=gray(.6))
hist(effectiveSize(beta_mcmc1), main="ess(beta) gjam1",lwd=2,col=gray(.6))
hist(effectiveSize(beta_mcmc2), main="ess(beta) gjam2",lwd=2,col=gray(.6))
hist(effectiveSize(beta_mcmc3), main="ess(beta) gjam3",lwd=2,col=gray(.6))
hist(effectiveSize(beta_mcmc4), main="ess(beta) gjam4",lwd=2,col=gray(.6))
par(mfrow=c(2,3))
hist(effectiveSize(beta_mcmc), main="ess(beta) gjam",lwd=2,col=gray(.6))
hist(effectiveSize(beta_mcmc1), main="ess(beta) gjam1",lwd=2,col=gray(.6))
hist(effectiveSize(beta_mcmc2), main="ess(beta) gjam2",lwd=2,col=gray(.6))
hist(effectiveSize(beta_mcmc3), main="ess(beta) gjam3",lwd=2,col=gray(.6))
hist(effectiveSize(beta_mcmc4), main="ess(beta) gjam4",lwd=2,col=gray(.6))
#check the last weight
pk_chains0<- fit$chains$pk_g
dim(pk_chains0)
pk_chains1- fit1$chains$pk_g
pk_chains1<- fit1$chains$pk_g
pk_chains1
dim(pk_chains1)
#check the last weight
pk_chains0_last<- fit$chains$pk_g[,ncol(fit$chains$pk_g)]
#check the last weight
pk_chains0_last<- mcmc(fit$chains$pk_g[,ncol(fit$chains$pk_g)])
pk_chains1_last<- mcmc(fit1$chains$pk_g[,ncol(fit1$chains$pk_g)])
plot(pk_chains1_last)
pk_chains2_last<- mcmc(fit2$chains$pk_g[,ncol(fit2$chains$pk_g)])
plot(pk_chains2_last)
plot(pk_chains3_last)
pk_chains3_last<- mcmc(fit3$chains$pk_g[,ncol(fit3$chains$pk_g)])
plot(pk_chains3_last)
pk_chains4_last<- mcmc(fit4$chains$pk_g[,ncol(fit4$chains$pk_g)])
plot(pk_chains4_last)
rm(fit1)
rm(fit2)
rm(fit4)
ml4   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl4) #change ml
ml3   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl3) #change ml
ml2   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl2) #change ml
ml1   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl1) #change ml
ml   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl) #change ml
rl2
rl2  <- list(r = 8, N = S,rate=0.1,shape=0.1,V=5) #here to modify N
rl2
rl4   <- list(r = 8, N = N_eps,rate=0.1,shape=0.1,V1=5,ro.disc=0.5) #here to modify N
ml4   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl4) #change ml
ml2   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl2) #change ml
ml1   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl1) #change ml
fit<-.gjam0(form, xdata = xdata, ydata = treeYdata, modelList = ml)
setwd("~/GitHub/gjamed")
source("R/simple_gjam_0.R")
rl <- list(r = 8, N = S,alpha.DP=S)
rl
rl <- list(r = 8, N = S,alpha.DP=S)
ml   <- list(ng = 5000, burnin = 500, typeNames = 'DA', reductList = rl) #change ml
fit<-.gjam0(form, xdata = xdata, ydata = treeYdata, modelList = ml)
ml2
ml4
fit1<-.gjam_1(form, xdata = xdata, ydata = treeYdata, modelList = ml1)
fit2<-.gjam_2(form, xdata = xdata, ydata = treeYdata, modelList = ml2)
fit4<-.gjam_4(form, xdata = xdata, ydata = treeYdata, modelList = ml4)
fit$fit$rmspeAll
fit1$fit$rmspeAll
fit2$fit$rmspeAll
fit3$fit$rmspeAll
fit4$fit$rmspeAll
#check that alpha and sigma posteriors
#gjam1
alpha<-mcmc(fit1$chains$alpha.DP_g)
plot(alpha)
#gjam2
alpha<-mcmc(fit2$chains$alpha.DP_g)
plot(alpha)
##gjam4
alpha<-mcmc(fit4$chains$alpha.PY_g)
plot(alpha)
alpha<-mcmc(fit4$chains$alpha.PY_g[1:20:length(fit4$chains$alpha.PY_g)])
alpha<-mcmc(fit4$chains$alpha.PY_g[seq(1,length(fit4$chains$alpha.PY_g),by=20)])
plot(alpha)
acfplot(alpha)
##gjam4
alpha<-mcmc(fit4$chains$alpha.PY_g)
acfplot(alpha)
cumuplot(alpha)
plot(alpha)
discount<-mcmc(fit4$chains$discount.PY_g)
plot(discount)
acfplot(discount)
cumuplot(discount)
gjam_mc<- mcmc(fit$chains$sgibbs)
gjam_mc1<- mcmc(fit1$chains$sgibbs)
gjam_mc2<- mcmc(fit2$chains$sgibbs)
gjam_mc3<- mcmc(fit3$chains$sgibbs)
gjam_mc4<- mcmc(fit4$chains$sgibbs)
par(mfrow=c(2,3))
hist(effectiveSize(gjam_mc), main="ess(sigma) gjam",lwd=2,col=gray(.6),breaks=100)
hist(effectiveSize(gjam_mc1), main="ess(sigma) gjam1",lwd=2,col=gray(.6),breaks=100)
hist(effectiveSize(gjam_mc2), main="ess(sigma) gjam2",lwd=2,col=gray(.6),breaks=100)
hist(effectiveSize(gjam_mc3), main="ess(sigma) gjam3",lwd=2,col=gray(.6),breaks=100)
hist(effectiveSize(gjam_mc4), main="ess(sigma) gjam4",lwd=2,col=gray(.6),breaks=100)
beta_mcmc<-mcmc(fit$chains$bgibbs)
beta_mcmc1<-mcmc(fit1$chains$bgibbs)
beta_mcmc2<-mcmc(fit2$chains$bgibbs)
beta_mcmc3<-mcmc(fit3$chains$bgibbs)
beta_mcmc4<-mcmc(fit4$chains$bgibbs)
#nESS
par(mfrow=c(2,3))
hist(effectiveSize(beta_mcmc), main="ess(beta) gjam",lwd=2,col=gray(.6))
hist(effectiveSize(beta_mcmc1), main="ess(beta) gjam1",lwd=2,col=gray(.6))
hist(effectiveSize(beta_mcmc2), main="ess(beta) gjam2",lwd=2,col=gray(.6))
hist(effectiveSize(beta_mcmc3), main="ess(beta) gjam3",lwd=2,col=gray(.6))
hist(effectiveSize(beta_mcmc4), main="ess(beta) gjam4",lwd=2,col=gray(.6))
alpha<-mcmc(fit2$chains$alpha.DP_g)
plot(alpha)
##gjam4
alpha<-mcmc(fit4$chains$alpha.PY_g)
plot(alpha)
discount<-mcmc(fit4$chains$discount.PY_g)
plot(discount)
trace0<-apply(fit$chains$kgibbs,1,function(x) length(unique(x)))
trace1<-apply(fit1$chains$kgibbs,1,function(x) length(unique(x)))
trace2<-apply(fit2$chains$kgibbs,1,function(x) length(unique(x)))
trace3<-apply(fit3$chains$kgibbs,1,function(x) length(unique(x)))
trace4<-apply(fit4$chains$kgibbs,1,function(x) length(unique(x)))
table<-data.frame()
table<-data.frame("trace"=c(trace0,trace1,trace2,trace3,trace4),
"type"=c(rep("0",length(trace0)),rep("1",length(trace1)),rep("2",length(trace2)),rep("3",length(trace3)),rep("4",length(trace4))),
"x"=rep(1:5000,5))
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
cols = gg_color_hue(5)
# traceplots altogether
p<-ggplot(table, aes(x=x,y=trace,col=as.factor(type)))+geom_point()+
scale_color_manual(name = c(""), values = cols, labels=c("Original model","DP with prior on alpha 1","DP with prior on alpha 2","PY with fixed alpha, sigma","PY with prior on alpha, sigma"))+
labs(title="Traceplots of the posterior of the number of clusters")
pdf("plots/forest_data_trace_K.pdf")
p
p
dev.off()
pdf("plots/forest_data_trace_K.pdf")
p
dev.off()
p
pk_chains0_last<- mcmc(fit$chains$pk_g[,ncol(fit$chains$pk_g)])
plot(pk_chains1_last)
pk_chains1_last<- mcmc(fit1$chains$pk_g[,ncol(fit1$chains$pk_g)])
plot(pk_chains1_last)
pk_chains2_last<- mcmc(fit2$chains$pk_g[,ncol(fit2$chains$pk_g)])
plot(pk_chains2_last)
pk_chains3_last<- mcmc(fit3$chains$pk_g[,ncol(fit3$chains$pk_g)])
plot(pk_chains3_last)
pk_chains4_last<- mcmc(fit4$chains$pk_g[,ncol(fit4$chains$pk_g)])
plot(pk_chains4_last)
pdf("plots_forest_data/forest_data_trace_K.pdf")
p
dev.off()
pdf("plots_forest_data/forest_data_trace_K.pdf")
p
dev.off()
pdf("plot_forest_data/forest_data_trace_K.pdf")
p
dev.off()
p<-ggplot(table, aes(x=x,y=trace,col=as.factor(type)))+geom_point()+
scale_color_manual(name = c(""), values = cols, labels=c("Original model","DP with prior on alpha 1","DP with prior on alpha 2","PY with fixed alpha, sigma","PY with prior on alpha, sigma"))+
labs(title="Traceplots of the posterior of the number of clusters")+xlab("iterations")
pdf("plot_forest_data/forest_data_trace_K.pdf")
p
dev.off()
View(forestTraits)
View(treeYdata)
save(fit,"models_forest_data.fit.rda")
save(fit,"models_forest_data/fit.rda")
save(fit,"models_forest_data/fit.Rda")
?save
save(fit,file="models_forest_data/fit.Rda")
fit1<-.gjam_1(form, xdata = xdata, ydata = treeYdata, modelList = ml1)
save(fit1,file="models_forest_data/fit1.Rda")
save(fit2,file="models_forest_data/fit2.Rda")
save(fit3,file="models_forest_data/fit3.Rda")
save(fit4,file="models_forest_data/fit4.Rda")
fit$fit$rmspeAll
fit1$fit$rmspeAll
fit2$fit$rmspeAll
fit3$fit$rmspeAll
fit4$fit$rmspeAll
treeYdataPA<- mapply(treeYdata,function(x){ifelse(x>0,1,0)})
treeYdataPA<- apply(treeYdata,c(1,2),function(x){ifelse(x>0,1,0)})
View(treeYdata)
View(treeYdataPA)
rm(list=ls())
setwd("~/GitHub/gjamed")
library(repmis)
library(gjam)
library(MASS)
library(truncnorm)
library(coda)
library(RcppArmadillo)
library(ggmcmc)
library(arm)
library(coda)
library(Rcpp)
library(ggplot2)
Rcpp::sourceCpp('src/cppFns.cpp')
source("R/gjamHfunctions_mod.R")
source("R/simple_gjam_0.R")
source("R/simple_gjam_1.R")
source("R/simple_gjam_2.R")
source("R/simple_gjam_3.R")
source("R/simple_gjam_4.R")
d <- "https://github.com/jimclarkatduke/gjam/blob/master/forestTraits.RData?raw=True"
source_data(d)
xdata <- forestTraits$xdata[,c(1,2,8)]
y  <- gjamReZero(forestTraits$treesDeZero)  # extract y
treeYdata  <- gjamTrimY(y,10)$y             # at least 10 plots
treeYdataPA<- apply(treeYdata,c(1,2),function(x){ifelse(x>0,1,0)})
form <- as.formula( ~ temp*deficit + I(temp^2) + I(deficit^2) )
S<-ncol(treeYdata) #95
it<-5000
burn<-500
rl <- list(r = 8, N = S,alpha.DP=S)
rl1 <- list(r = 8, N = S, rate=0.1,shape=0.1)
rl2  <- list(r = 8, N = S,rate=0.1,shape=0.1,V=5) #here to modify N
N_eps<-floor(.compute_tau_mean(0.3,10,0.1) + 2*.compute_tau_var(0.3,10,0.1)) #alpha=10,sigma=0.3
rl3   <- list(r = 8, N = N_eps, sigma_py=0.3, alpha=2)
N_eps<-floor(.compute_tau_mean(0.5,10,0.1) + 2*.compute_tau_var(0.5,10,0.1))
rl4   <- list(r = 8, N = N_eps,rate=0.1,shape=0.1,V1=5,ro.disc=0.5) #here to modify N
ml4   <- list(ng = it, burnin = burn, typeNames = 'DA', reductList = rl4) #change ml
ml3   <- list(ng = it, burnin = burn, typeNames = 'DA', reductList = rl3) #change ml
ml2   <- list(ng = it, burnin = burn, typeNames = 'DA', reductList = rl2) #change ml
ml1   <- list(ng = it, burnin = burn, typeNames = 'DA', reductList = rl1) #change ml
ml   <- list(ng = it, burnin = burn, typeNames = 'DA', reductList = rl) #change ml
ml4   <- list(ng = it, burnin = burn, typeNames = 'PA', reductList = rl4) #change ml
ml3   <- list(ng = it, burnin = burn, typeNames = 'PA', reductList = rl3) #change ml
ml2   <- list(ng = it, burnin = burn, typeNames = 'PA', reductList = rl2) #change ml
ml1   <- list(ng = it, burnin = burn, typeNames = 'PA', reductList = rl1) #change ml
ml   <- list(ng = it, burnin = burn, typeNames = 'PA', reductList = rl) #change ml
fit<-.gjam0(form, xdata = xdata, ydata = treeYdataPA, modelList = ml)
rl <- list(r = 5, N = S,alpha.DP=S)
rl1 <- list(r = 5, N = S, rate=0.1,shape=0.1)
rl2  <- list(r = 5, N = S,rate=0.1,shape=0.1,V=5) #here to modify N
N_eps<-floor(.compute_tau_mean(0.3,10,0.1) + 2*.compute_tau_var(0.3,10,0.1)) #alpha=10,sigma=0.3
rl3   <- list(r = 5, N = N_eps, sigma_py=0.3, alpha=2)
N_eps<-floor(.compute_tau_mean(0.5,10,0.1) + 2*.compute_tau_var(0.5,10,0.1))
rl4   <- list(r = 5, N = N_eps,rate=0.1,shape=0.1,V1=5,ro.disc=0.5) #here to modify N
ml4   <- list(ng = it, burnin = burn, typeNames = 'PA', reductList = rl4) #change ml
ml3   <- list(ng = it, burnin = burn, typeNames = 'PA', reductList = rl3) #change ml
ml2   <- list(ng = it, burnin = burn, typeNames = 'PA', reductList = rl2) #change ml
ml1   <- list(ng = it, burnin = burn, typeNames = 'PA', reductList = rl1) #change ml
ml   <- list(ng = it, burnin = burn, typeNames = 'PA', reductList = rl) #change ml
fit<-.gjam0(form, xdata = xdata, ydata = treeYdataPA, modelList = ml)
fit1<-.gjam_1(form, xdata = xdata, ydata = treeYdataPA, modelList = ml1)
save(fit1,file="models_forest_data_PA/fit1.Rda")
rl <- list(r = 3, N = S,alpha.DP=S)
ml   <- list(ng = it, burnin = burn, typeNames = 'PA', reductList = rl) #change ml
fit<-.gjam0(form, xdata = xdata, ydata = treeYdataPA, modelList = ml)
>>>>>>> d53fa8c2be02ae70511ec5d7ae49fad76e5ad8e2
